/*
 * Software Development Kit for Fisilink
 * @file: regtbl.h
 * @description:
 * @note: Copyright (C) 2020 
 *
 * You should have received a copy of the Fisilink License
 * along with this program; if not, write to Fisilink
 */


#ifndef __REG_TBL_H
#define __REG_TBL_H

#include "rbtree.h"
#include <pthread.h>

/** define the maximum field number in one command line */
const static uint8_t MAX_FLD_NUM=64;

/** Table or Register type enum */
typedef enum MemRegType {
    eIRAM,                      ///< Inner RAM
    eORAM,                      ///< Outer RAM
    eDRAM,                      ///< DRAM
    eLPM,                       ///< LPM space
    eTCAM,                      ///< TCAM space
    eEM,                        ///< Excat Memory space
    eHASH,                      ///< HASH space
    eMEM_DIRECT,                ///< Direct Memory Address
    eMEM_INDIRECT               ///< Indirect Memory Address
} eMemRegType;

/** Common struct for all Tables and Registers */
typedef struct MemReg {
    uint32_t uid;               ///< Unique Identifier of memory or reg generated by hash function of name
    uint8_t *name;              ///< Memory or Reg name
    eMemRegType type;           ///< Memory or Reg Type
    uint16_t usedDwords;        ///< Width of memory or reg align to 4 Bytes
    uint16_t entrySize;         ///< Used for calculate the address of every table entry, which is widthInQuad up to power 2
    uint32_t attachBus;         ///< attachment bus NO.

    /** union entry nuber for linear memory space and matrix memory space */
    union EntryNum {
        uint64_t entries;       ///< number of entries this memory or reg
        /** momory size definition for matrix memory */
        struct MemSize {
            uint32_t rowNum;    ///< number of rows if it is in block
            uint32_t colNum;    ///< number of column if it is in block
        } matrixSize ; 
    } entryNum;

    /** union base address for linear memory space and matrix memory space */
    union BaseAddr {
        uint64_t linearAddr;    ///< base address of memory or reg in linear address space
        /** momory address base definition for matrix memory */
        struct MemBase {
            uint32_t rowBase;   ///< base row of memory or reg in block space
            uint32_t colBase;   ///< base column of memory or reg in block space
        } matrixBase ;
    } addrBase;

    void *entryList;            ///< Pointer of entry array, each of which keeps context of entry value
    char **fldNameList;         ///< storage all field name for search 
    pthread_rwlock_t *rwLockList; ///< read/write lock, one for one entry

    /** read mem/reg @ index to output as digital */
    int32_t  (*read)    ( struct MemReg *memPtr, uint32_t index, void *output, uint8_t fromWhere ); 

    /** write mem/reg @ index using parav which are all assignment expressions */
    int32_t  (*write)   ( struct MemReg *memPtr, uint32_t index, uint16_t parac, char *parav[], void *output, uint8_t fromWhere );

    /** set mem/reg @ index using data */
    int32_t  (*set)     ( struct MemReg *memPtr, uint32_t index, void *data, void *output, uint8_t fromWhere );

    /** set mem/reg with new value field by field in flds */
    int32_t  (*fldSet)  ( void *data, uint32_t nflds, char *flds[] );

    /** get mem/reg @ index fldName field value to output */
    uint32_t (*fldGet)  ( struct MemReg *memPtr, uint32_t index, uint8_t *fldName, void *output, uint8_t fromWhere );

    /** print mem/reg whose value in data */
    uint32_t (*print)   ( char *fmtStr, void *data );

    /** reset mem/reg to default value */
    int32_t  (*reset)   ( struct MemReg *memPtr, uint8_t flag );

    /** destroy all mem/reg */
    int32_t  (*destroy) ( struct MemReg *memPtr );
    struct rb_node rbnode;      ///< Red-Black tree node used to build RB tree for all memory and reg, to speed up search procession
} tMemRegHdr;

#endif
